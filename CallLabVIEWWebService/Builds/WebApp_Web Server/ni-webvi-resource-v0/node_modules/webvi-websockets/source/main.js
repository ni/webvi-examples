// ****************************************
// WebSocket Wrapper Functions
// National Instruments Copyright 2019
// ****************************************

(function () {
    'use strict';

    // LabVIEW NXG Web Sockets Addon Error code range: 21500 to 21599 (100 total)
    // TODO the following error code assignments are not final yet
    // TODO we should re-use error codes where possible (invalid refnum, timeout, etc)
    const invalidRefnumMessage = 'Invalid Refnum LVError(21500)';
    const invalidUrlOrProtocolsMessage = 'Invalid URL or protocols LVError(21501)';
    const errorOccurredMessage = 'WebSocket Error occurred LVError(21502)';
    const connectionClosedMessage = 'Websocket connection closed LVError(21503)';
    const cannotSendMessage = 'Could not send message LVError(21504)';
    const cannotReadMessage = 'Unable to read message LVError(21505)';
    const readStringWrongMessageType = 'Read string was used to read a non-string message LVError(21506)';
    const readByteArrayWrongMessageType = 'Read byte array was used to read a non-binary message LVError(21507)';
    const readTimeoutMessage = 'The network operation exceeded the user-specified or system time limit LVError(56)';

    class DataQueue {
        constructor () {
            this._queue = [];
            this._pendingResolve = undefined;
            this._pendingReject = undefined;
            this._preDequeueTest = undefined;
        }

        _clearPending () {
            this._pendingResolve = undefined;
            this._pendingReject = undefined;
            this._preDequeueTest = undefined;
        }

        enqueue (data) {
            if (this._queue === undefined) {
                throw new Error(`The queue has already been destroyed, cannot enqueue new data: ${data}`);
            }

            this._queue.push(data);

            if (this._pendingResolve !== undefined) {
                const pendingResolve = this._pendingResolve;
                const pendingReject = this._pendingReject;
                const preDequeueTest = this._preDequeueTest;
                this._clearPending();
                try {
                    preDequeueTest(this._queue[0]);
                    // If preDequeueTest throws then in the following we won't dequeue the message
                    pendingResolve(this._queue.shift());
                } catch (error) {
                    pendingReject(error);
                }
            }
        }

        dequeue (setAbortHandler, preDequeueTest) {
            if (this._queue === undefined) {
                throw new Error('The queue has already been destroyed, cannot dequeue any data.');
            }

            if (this._pendingResolve !== undefined) {
                throw new Error(cannotReadMessage);
            }

            if (this._queue.length === 0) {
                return new Promise((resolve, reject) => {
                    this._pendingResolve = resolve;
                    this._pendingReject = reject;
                    this._preDequeueTest = preDequeueTest;
                    setAbortHandler(() => {
                        // The pending resolve / reject will be undefined if a value is enqueued
                        // and the pending dequeue is resolved before abort is called in cleanup
                        if (this._pendingResolve === resolve) {
                            this._clearPending();
                        }
                    });
                });
            }

            preDequeueTest(this._queue[0]);
            // If preDequeueTest throws then in the following we won't dequeue the message
            return this._queue.shift();
        }

        destroy () {
            const remaining = this._queue;
            this._queue = undefined;

            if (this._pendingResolve !== undefined) {
                const toReject = this._pendingReject;
                this._clearPending();
                toReject(new Error('Pending dequeue operation failed due to queue destruction.'));
            }

            return remaining;
        }
    }

    const swallowError = async function (asyncfn) {
        try {
            return await asyncfn();
        } catch (ex) {
            return undefined;
        }
    };

    // TODO maybe use AbortController in the future
    const createAbortableTimeout = function (timeout_ms) {
        // All browsers use Int32 max to represent timeout, ie Math.pow(2,31)-1, about 24.8 days
        const maxSafeTimeout_ms = 2147483647;
        let timeoutId;
        const timeoutPromise = new Promise((resolve, reject) => {
            if (Number.isNaN(timeout_ms) || timeout_ms < 0) {
                // Never timeout. This promise will never fulfill or reject
                timeoutId = undefined;
            } else if (timeout_ms === 0) {
                // Return an immediately timed out Promise
                timeoutId = undefined;
                reject(new Error(readTimeoutMessage));
            } else {
                const timeout_ms_safe = timeout_ms > maxSafeTimeout_ms ? maxSafeTimeout_ms : timeout_ms;
                timeoutId = setTimeout(() => {
                    reject(new Error(readTimeoutMessage));
                }, timeout_ms_safe);
            }
        });
        const timeoutAbort = () => {
            if (timeoutId !== undefined) {
                clearTimeout(timeoutId);
            }
        };
        return {
            timeoutPromise,
            timeoutAbort
        };
    };

    // TODO maybe use AbortController in the future
    const createAbortableMessageDequeue = function (messageQueue, preDequeueTest) {
        let messageDequeueAbort = () => {
            // default abort handler is a no-op
        };

        // If a promise is created then update the abort handler
        const messageDequeueAbortSetter = (messageDequeueAbortIn) => {
            messageDequeueAbort = messageDequeueAbortIn;
        };

        const messageDequeuePromise = messageQueue.dequeue(messageDequeueAbortSetter, preDequeueTest);
        return {
            messageDequeuePromise,
            messageDequeueAbort
        };
    };

    const MESSAGE_TYPE = Object.freeze({
        BINARY: 'BINARY',
        STRING: 'STRING'
    });

    const stringPreDequeueTest = function (message) {
        if (typeof message !== 'string') {
            throw new Error(readStringWrongMessageType);
        }
    };

    const binaryPreDequeueTest = function (message) {
        if (message instanceof ArrayBuffer === false) {
            throw new Error(readByteArrayWrongMessageType);
        }
    };

    const getPreDequeueTest = function (messageType) {
        switch (messageType) {
        case MESSAGE_TYPE.STRING:
            return stringPreDequeueTest;
        case MESSAGE_TYPE.BINARY:
            return binaryPreDequeueTest;
        default:
            throw new Error(`Unsupported message type: ${messageType}`);
        }
    };

    // The WebSocket object provides a promise oriented interface to the different WebSocket operations
    class NIWebSocket {
        constructor (url, protocols) {
            this._webSocket = undefined;
            try {
                this._webSocket = new WebSocket(url, protocols);
            } catch (error) {
                throw new Error(invalidUrlOrProtocolsMessage);
            }
            this._webSocket.binaryType = 'arraybuffer';
            this._messageQueue = new DataQueue();

            const handlers = {
                open: undefined,
                close: undefined,
                error: undefined,
                message: undefined
            };

            const cleanupHandlers = () => {
                Object.keys(handlers).forEach((name) =>{
                    this._webSocket.removeEventListener(name, handlers[name]);
                    handlers[name] = undefined;
                });
            };

            this._opened = new Promise((resolve) => {
                handlers.open = () => {
                    resolve(this._webSocket.protocol);
                };
            });

            this._closed = new Promise((resolve, reject) => {
                handlers.close = () => {
                    cleanupHandlers();
                    reject(new Error(connectionClosedMessage));
                };
            });

            this._errored = new Promise((resolve, reject) => {
                handlers.error = () => {
                    cleanupHandlers();
                    reject(new Error(errorOccurredMessage));
                };
            });

            handlers.message = (event) => {
                // TODO if enqueue errors what should we do?
                // Is it even possible? Maybe just a good assert, or wrap exception in more context?
                // I guess erroring is more likely with a fixedsize queue
                this._messageQueue.enqueue(event.data);
            };

            Object.keys(handlers).forEach((name) => {
                this._webSocket.addEventListener(name, handlers[name]);
            });
        }

        async open () {
            return await Promise.race([
                this._errored,
                this._closed,
                this._opened
            ]);
        }

        send (message) {
            try {
                this._webSocket.send(message);
            } catch (error) {
                throw new Error(cannotSendMessage);
            }
        }

        async read (messageType, timeout_s) {
            const timeout_ms = timeout_s * 1000;
            const {timeoutPromise, timeoutAbort} = createAbortableTimeout(timeout_ms);
            const {messageDequeuePromise, messageDequeueAbort} = createAbortableMessageDequeue(this._messageQueue, getPreDequeueTest(messageType));
            try {
                const result = await Promise.race([
                    messageDequeuePromise, // check first to allow the queue to be serviced even if there are pending error / closed / timeout messages
                    this._errored,
                    this._closed,
                    timeoutPromise
                ]);
                if (messageType === MESSAGE_TYPE.BINARY) {
                    return new Uint8Array(result);
                }
                return result;
            } finally {
                // Cleanup the new promises made in this scope
                // For example if timeout occurred, next message should go to queue instead of resolving this pending promise
                messageDequeueAbort();
                timeoutAbort();
            }
        }

        async close () {
            this._webSocket.close();

            const closePromise = swallowError(async () => {
                return await this._closed;
            });

            await Promise.race([
                closePromise,
                this._errored
            ]);

            this._messageQueue.destroy();
            this._messageQueue = undefined;
        }
    }

    // Refnum manager to manage NIWebSocket objects
    let nextRefnum = 1;
    class RefnumManager {
        constructor () {
            this.refnums = new Map();
        }

        createRefnum (obj) {
            const refnum = nextRefnum;
            nextRefnum += 1;
            this.refnums.set(refnum, obj);
            return refnum;
        }

        getObject (refnum) {
            return this.refnums.get(refnum);
        }

        closeRefnum (refnum) {
            this.refnums.delete(refnum);
        }
    }

    const refnumManager = new RefnumManager();

    // Find an existing refnum error if not found
    const findRefnum = function (refnum) {
        const obj = refnumManager.getObject(refnum);
        if (obj === undefined) {
            throw new Error(invalidRefnumMessage);
        }
        return obj;
    };

    const parseProtocols = function (protocolsJSON) {
        let protocols;
        try {
            protocols = JSON.parse(protocolsJSON);
        } catch (ex) {
            throw new Error(`Protocols is not a valid JSON format. Protocols JSON: ${protocolsJSON} Error message: ${ex.message}`);
        }
        if (Array.isArray(protocols) === false || protocols.every(protocol => typeof protocol === 'string') === false) {
            throw new Error(`Invalid format for protocols, expected an array of zero or more strings. Protocols JSON: ${protocolsJSON}`);
        }
        return protocols;
    };

    // Wait for a connection to open to the desired server
    const open = async function (url, protocolsJSON) {
        const protocols = parseProtocols(protocolsJSON);
        const niWebSocket = new NIWebSocket(url, protocols);
        const protocol = await niWebSocket.open();
        const refnum = refnumManager.createRefnum(niWebSocket);
        const openResult = JSON.stringify({
            refnum,
            protocol
        });
        return openResult;
    };

    // Send either a string or binary message
    const send = function (refnum, message) {
        const niWebSocket = findRefnum(refnum);
        niWebSocket.send(message);
    };

    // Attempt to read a pending message as a string
    const readString = function (refnum, timeout_s) {
        const niWebSocket = findRefnum(refnum);
        return niWebSocket.read(MESSAGE_TYPE.STRING, timeout_s);
    };

    // Attempt to read a pending message as a Uint8Array
    const readByteArray = function (refnum, timeout_s) {
        const niWebSocket = findRefnum(refnum);
        return niWebSocket.read(MESSAGE_TYPE.BINARY, timeout_s);
    };

    // Wait for close of an existing websocket connection
    const close = async function (refnum) {
        const niWebSocket = findRefnum(refnum);
        refnumManager.closeRefnum(refnum);
        await niWebSocket.close();
    };

    // Register namespace
    if (window.NationalInstrumentsWebSockets === undefined) {
        window.NationalInstrumentsWebSockets = {};
    }

    window.NationalInstrumentsWebSockets.open = open;
    window.NationalInstrumentsWebSockets.sendString = send;
    window.NationalInstrumentsWebSockets.sendByteArray = send;
    window.NationalInstrumentsWebSockets.readString = readString;
    window.NationalInstrumentsWebSockets.readByteArray = readByteArray;
    window.NationalInstrumentsWebSockets.close = close;
}());
